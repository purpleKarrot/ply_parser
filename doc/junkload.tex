\documentclass[a4paper,parskip=half]{scrartcl}
%
\usepackage{a4wide}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{times}
%
\usepackage{listings}
\lstset{basicstyle=\ttfamily\scriptsize\mdseries}
%
\usepackage{hyperref}
\hypersetup{colorlinks=true}
\urlstyle{same}
%
\title{Parsing Chunks out of PLY Files\\in a Multithreaded Environment}
\author{Daniel Pfeifer}
%
\begin{document}
%
\maketitle
%
\begin{abstract}
\url{http://graphics.stanford.edu/data/3Dscanrep/}\\
PLY files are common\\
used for big data\\
often only a part of this data is required\\
no routine available to get this part\\
implement a generic library for this purpose\\
\end{abstract}
%
\section{Introduction}
The PLY file format is a simple object description that was designed as a
convenient format for researchers who work with polygonal models.

A PLY file consists of a header followed by a list of vertices and then a list of
polygons. The header specifies how many vertices and polygons are in the file,
and also states what properties are associated with each vertex, such as (x,y,z)
coordinates, normals and color. The polygon faces are simply lists of indices
into the vertex list, and each face begins with a count of the number of elements
in each list.

Source code for programs that read and write PLY files can be found in the PLY
code archive. This archive includes programs to transform polygonal objects,
calculate surface normals, flip faces and determine the spatial bounds of an
object. We plan to make additional tools available in the near future.

\subsection{related work}
%
ply.c and libply

\subsubsection{ply.c}
written in c\\
old\\
does not compile on modern compilers\\
only covers ply core\\

\subsubsection{libply}
\url{http://people.cs.kuleuven.be/~ares.lagae/libply/}
uses boost and tr1\\
covers full spec\\
uses callbacks (for all combination of types!)\\

Libply's ply parser supports the complete PLY file format. However, the ply
parser is considerably more complex than parsers for other 3D file formats. This
is because a PLY file can contain any kind of data, a PLY file consist of a
header containing a specification of the kind of data, and the data itself. For
more information, refer to the ply specification.

Libply's Wavefront ply parser is event-based, which makes it easy to integrate
and well suited for parsing very large files (such as the 28 million triangles
Lucy model). Libply's Wavefront ply parser reports errors, which is especially
useful for handling the large variety of ply files out there. Libply is a modern
C++ library written in standard C++, and uses TR1's function objects as an
efficient and flexible callback mechanism.

\subsection{Generic Programming Techniques}
Generic programming is about writing code that is independent of the types of
objects being manipulated. In C++, class and function templates are particularly
effective mechanisms for generic programming because they make the generalization
possible without sacrificing type safety and efficiency.

A concept is a set of requirements consisting of valid expressions, associated
types, invariants, and complexity guarantees. A type that satisfies the
requirements is said to \emph{model} the concept. A concept can extend the
requirements of another concept, which is called \emph{refinement}.

The concepts used in the C++ Standard Library are documented at the SGI STL
site\footnote{\url{http://www.sgi.com/tech/stl/table_of_contents.html}}.

which concepts are required for chunk loaders\\
which concepts do different file reading libraries provide?\\
can we wrap them?\\
is it useful?\\
conclusion: streams have to be read in one run\\

\subsection{multithreading}
%
one file!\\
threadsafe, as long as each file is accessed from one thread only!\\
-> build single threaded, then use std::async or Boost.Thread.\\

\subsection{about ply}
different meaning of 'generic'\\
handling generic data is close to impossible in static typed language\\
instead, convert to the format that the user requires\\
this can be achieved with generic programming\\

\section{approach}
%
\begin{lstlisting}[frame=tb]
ply      = "ply" EOL "format" format DOUBLE EOL element* "end_header" EOL;
element  = "element" STRING INT EOL property*;
property = "property" (list | scalar) STRING EOL;
list     = "list" size scalar;
format   = "ascii" | "binary_little_endian"| "binary_big_endian";
size     = "uint8" | "uint16"| "uint32" | "uint64";
scalar   = size | "int8" | "int16" | "int32" | "int64" | "float32" | "float64";
\end{lstlisting}

header has always the same grammar (show EBNF)\\
body grammar is built from header\\
lex-yacc not possible\\
spirit possible\\
spirit also much less verbose, direct EBNF conversion\\
show header grammar in spirit\\
body grammar generation\\
output type cannot be build, subparser need to insert their value\\

\section{application}
%
\subsection{provided}
forward wrapper (spirit)\\
line saver for error messages (spirit)\\
iostream for .gz and .bz2 (iostreams)\\
async (c++0x or Boost.Task or Boost.Thread?)\\

\subsection{custom}
parser: parse line depending on grammar\\
p\_iter: InputIterator parses input lines on increment\\
interval: OutputIterator wrapper, ignore outside of interval\\

\section{examples}
read interval from .ply.gz in parallel thread and enable error output.

\section{conclusion}

\end{document}
